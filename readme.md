## 프로세스 및 예상 구현 
1. 상품 화면 - 상태(초기 상태)
   - SalesItem 정보 API


2. 결제 화면 진입 - 행위
   - 주문 API 
   - 주문 정보 Redis 캐싱(SCARD 프로세스를 통해 재고 사용량 확인 가능)
   - 해당 구간에서 캐싱한 재고 사용량 > 재고라면 주문 불가
   

3. 결제 화면 - 상태
    - Redis Pub/Sub 구조를 활용한 HeartBeat
    - HeartBeat 실패 시 주문 정보 캐싱 삭제(SREM) 
   


4. 결제 시도 - 행위
   - 결제 API 호출
   - 결제 API는 캐싱한 주문 정보를 확인하고, 주문 데이터 저장(RDBMS)
   - 주문 정보 캐싱한 것을 삭제하고(SREM) SalesItemEntity에서 stock을 감소(RDMBS)
   - 기본적으로 재고가 존재하는 경우 결제가 되지만, 한번더 검증
   

5. 결제 중 - 상태
   - 트랜잭션에서 에러처리가 된다면 롤백
   

6. 결제 완료 - 상태


## 예상 문제
1. **[최종 결제 수 > 전체 상품 수] 발생으로 인한 결제 취소**
   - Redis 원자성 보장 
   - 기본 재고 사용량을 캐싱하고 RDBMS의 재고와 비교
   

2. 상품페이지 재고 수가 정확하지 않음 -> 후순위 상품 페이지에 얼마나 머무는지에 따라 달라질 거라 예상함
   1. 재고가 있음에도 결제 화면 도입 불가
   2. 재고가 없다 하여 포기했는데 나보다 늦게 시도한 사람이 오히려 성공
   3. 같은 시각 상품페이지에 진입한 두 사람의 화면에 표기된 재고 수량이 다름
   
   
3. 결제 화면 도입 이후 결제 시도 불가
   - 고민사항 1 : 캐싱된 주문사항이 없을 때, 결제 시도를 할 수 있게 할 것인가?
     - Redis에 문제가 생긴다면?

4. 서비스 불가 
   1. 트래픽 몰림으로 인해 서버 다운
      - 현재 Redis Pub/Sub구조는 10만 이상 대규모 트래픽 시 문제가 될 가능성이 있음
      - 단일 노드를 지원하며, 클러스터링을 지원하지 않기 때문에 단일 Redis 서버가 감당하기 힘들 수 있음
      - 추후 개선 예정

   2. 예약 구매 상품과 상관 없는 고객들이 불편을 겪음
      - Redis는 주문 관련 Service에만 사용되기 때문에 영향이 없을 것이라 판단      
   


5. 오픈 시간 이전 구매 가능(어뷰징)
   - 서버시간 기준, Table에 start_time을 저장하여, start_time이전, end_time 이후 주문 로직 호출 X


## API 명세서
**OrderService**
[OrderService(:8085)](https://www.notion.so/b49b52a62b904ebc91a22a3ccd4b6cb2?pvs=21)
